#!/bin/bash

# Parse arguments. Generated by parse-options.sh.
_new_arguments=()
while [[ $# -gt 0 ]]; do
    case "$1" in
        --help|-h) help=1; shift ;;
        --version|-v) version=1; shift ;;
        --[^-]*) shift ;;
        *) _new_arguments+=("$1"); shift ;;
    esac
done
set -- "${_new_arguments[@]}"
_new_arguments=()
while [[ $# -gt 0 ]]; do
    case "$1" in
        -[^-]*) OPTIND=1
            while getopts ":hv" opt; do
                case $opt in
                    h) help=1 ;;
                    v) version=1 ;;
                esac
            done
            shift "$((OPTIND-1))"
            ;;
        *) _new_arguments+=("$1"); shift ;;
    esac
done
set -- "${_new_arguments[@]}"
unset _new_arguments

# Functions.
printVersion() {
    echo '0.1.0'
}
printHelp() {
    cat << 'EOF' >&2
Usage: ssh.sh <command> [options]'

Commands:
     list, l
        List the symbolic links that reference to this binary `ssh.sh` command.
     create, c <filename>
        Create symbolic links of filename that reference to this binary `ssh.sh` command.
     rename, r <filename> <newfilename>
        Rename symbolic links from filename to rename, the links is reference to this binary `ssh.sh` command.
     delete, d <filename>
        Delete symbolic links of filename that reference to this binary `ssh.sh` command.
     execute, x <pattern>
        Execute the pattern. Its proper to test before create the symbolic links.

The pattern of filename: <host>,<type>.<key>[,<value>][.<key>[,<value>]]...
     host, is alias inside ~/.ssh/config
     type is 'lpf' for local port forwarding, 'rpf' for remote port forwarding.
        'dpf' for dynamic port forwarding.
     available of key or key,value:
        'rport,22' means remote port with value is 22.
        'lport,auto' means remote port with value is fill automatically
        'lport,10123' means local port with value is 10123.
        'noloopback' means not using IP loopback (127.0.0.1) for target forwarding.
        'triggerusehost' means the trigger will use hostname instead of loopback (127.0.0.1)
        'trigger,no' not auto lunch apps that link of remote port.

Example of <filename>:
     server1,go
     server1,rpf.rport,12257.lport,22
     pcfaris,dpf.lport,9090
     pcdina,lpf.rport,rdp.lport,11300.triggerusehost
     pcpuji,lpf.rport,rdp.lport,10302.triggerusehost.from,pchadi
     pcfarah,lpf.rport,vnc.lport,10901.noloopback
     pcfaris,lpf.rport,ssh.lport,10002
     pcroni,lpf.rport,vpn.lport,11103.noloopback.triggerusehost
     cctv3,lpf.rport,http.lport,20102.jump,p.from,pcpuji
     s,lpf.rport,mysql.lport,30100
     pcfaris,lpf.rport,33899.lport,10001.trigger,rdp
     pcfaris,lpf.rport,ssh.lport,10002.trigger,no
     pcroni,lpf.rport,9090.lport,11104.trigger,http.from,pcfaris

This script usually to create ssh tunneling with local/remote/dynamic port forwarding.
EOF
}

# Help and Version.
[ -n "$version" ] && { printVersion; exit 1; }
[ -n "$help" ] && { printHelp; exit 1; }

# Common Functions.
red() { echo -ne "\e[91m" >&2; echo -n "$@" >&2; echo -e "\e[39m" >&2; }
green() { echo -ne "\e[92m" >&2; echo -n "$@" >&2; echo -e "\e[39m" >&2; }
yellow() { echo -ne "\e[93m" >&2; echo -n "$@" >&2; echo -e "\e[39m" >&2; }
blue() { echo -ne "\e[94m" >&2; echo -n "$@" >&2; echo -e "\e[39m" >&2; }
magenta() { echo -ne "\e[95m" >&2; echo -n "$@" >&2; echo -e "\e[39m" >&2; }
x() { exit 1; }

# Functions.
isWSL() {
    if [ -f /proc/sys/kernel/osrelease ];then
        read osrelease </proc/sys/kernel/osrelease
        if [[ "$osrelease" =~ microsoft || "$osrelease" =~ Microsoft ]];then
            return 0
        fi
    fi
    return 1
}
getPid() {
    if [[ $(uname) == "Linux" ]];then
        pid=$(ps aux | grep "$2" | grep -v grep | awk '{print $2}')
        echo $pid
    elif [[ $(uname | cut -c1-6) == "CYGWIN" ]];then
        local pid command ifs
        ifs=$IFS
        ps -s | grep "$1" | awk '{print $1}' | while IFS= read -r pid; do\
            command=$(cat /proc/${pid}/cmdline | tr '\0' ' ')
            command=$(echo "$command" | sed 's/\ $//')
            IFS=$ifs
            if [[ "$command" == "$2" ]];then
                echo $pid
                break
            fi
        done
        IFS=$ifs
    fi
}
translatePort() {
    local port
    case $1 in
        http) port=80 ;;
        rdp) port=3389 ;;
        vnc) port=5900 ;;
        ssh) port=22 ;;
        mysql) port=3306 ;;
        vpn) port=1194 ;;
    esac
    [ -n "$port" ] && echo "$port" || echo "$1"
}
getIP() {
    # https://stackoverflow.com/questions/12779134/parsing-ssh-config-for-proxy-information
    awk -v H="$1" '
    tolower($1) == "host" { m=$2 == H }
    tolower($1) == "hostname" && m{ print $2 }
    ' ~/.ssh/config
}
Ssh_list() {
    find -L "$__DIR__" -maxdepth 1 -samefile "$__FILE__" | grep -v 'ssh\.sh$' | grep -o -P "$__DIR__/"'\K(.*)'
}
Ssh_create() {
    [ -z "$1" ] && { red "Missing Argument."; x; }
    local pattern="$1"
    local local_port last
    local_port=$(grep -Eo '\.lport,[^.]+' <<< "$pattern" | sed -E 's/\.lport,(.*)/\1/')
    if [[ $local_port == 'auto' ]];then
        last=$(find -L "$__DIR__" -samefile "$__FILE__" | grep -v 'ssh\.sh$' | grep -o -P 'lport,\K(\d+)' | sort -n | tail -n1)
        [ -z "$last" ] && last=10000
        if [ $last -lt 10000 ];then
            next=$(( last + 10000 ))
        else
            next=$(( last + 1 ))
        fi
        pattern=$(sed "s/lport,auto/lport,${next}/"  <<< "$pattern")
    fi
    filename="${__DIR__}/$pattern"
    magenta ln -sf \""$__FILE__"\" \""$filename"\"
    ln -sf "$__FILE__" "$filename"
    if [ -h "$filename" ];then
        green Link created.
    else
        red Failed to create the link; x
    fi
}
Ssh_delete() {
    [ -z "$1" ] && { red "Missing Argument."; x; }
    filename="${__DIR__}/$1"
    if [[ -h "$filename" ]];then
        magenta rm -rf \""$filename"\"
        rm -rf "$filename"
        if [ ! -f "$filename" ];then
            green Link deleted.
        else
            red Failed to delete the link; x
        fi
    else
        red Link not found.
    fi
}
Ssh_rename() {
    [ -z "$1" ] && { red "Missing Argument."; x; }
    [ -z "$2" ] && { red "Missing Argument."; x; }
    local source="${__DIR__}/$1"
    local target="${__DIR__}/$2"
    if [[ -h "$source" ]];then
        magenta mv \""$source"\" \""$target"\"
        mv "$source" "$target"
        if [ -f "$target" ];then
            green Link renamed.
        else
            red Failed to rename the link; x
        fi
    else
        red Link not found. >&2
    fi
}
Ssh_execute() {
    [ -z "$1" ] && { red "Missing Argument."; x; }
    local pattern="$1"
    local local_port last
    local_port=$(grep -Eo '\.lport,[^.]+' <<< "$pattern" | sed -E 's/\.lport,(.*)/\1/')
    if [[ $local_port == 'auto' ]];then
        last=$(find -L "$__DIR__" -samefile "$__FILE__" | grep -v 'ssh\.sh$' | grep -o -P 'lport,\K(\d+)' | sort -n | tail -n1)
        [ -z "$last" ] && last=10000
        if [ $last -lt 10000 ];then
            next=$(( last + 10000 ))
        else
            next=$(( last + 1 ))
        fi
        pattern=$(sed "s/lport,auto/lport,${next}/"  <<< "$pattern")
    fi
    head=$(echo "$pattern" | cut -d'.' -f 1)
    host=$(echo "$head" | cut -d',' -f 1)
    variant=$(echo "$head" | cut -d',' -f 2)
    # Spasi harus single agar sama dengan isi di file /proc/${pid}/cmdline
    CMD=$( cat <<'EOL'
ssh -o ServerAliveInterval=10 -o ServerAliveCountMax=2 -o PreferredAuthentications=publickey -o PasswordAuthentication=no OPTION HOST
EOL
)
    case "$variant" in
        go)
            remote_port=22
            ip="$host"
            ;;
        lpf|rpf)
            OPTION=
            remote_port=$(grep -Eo '\.rport,[^.]+' <<< "$pattern" | sed -E 's/\.rport,(.*)/\1/')
            remote_port=$(tail -n1 <<< "$remote_port")
            remote_port=$(translatePort "$remote_port")
            local_port=$(grep -Eo '\.lport,[^.]+' <<< "$pattern" | sed -E 's/\.lport,(.*)/\1/')
            local_port=$(tail -n1 <<< "$local_port")
            local_port=$(translatePort "$local_port")
            from=$(grep -Eo '\.from,[^.]+' <<< "$pattern" | sed -E 's/\.from,(.*)/\1/')
            from=$(tail -n1 <<< "$from")
            jump=$(grep -Eo '\.jump,[^.]+' <<< "$pattern" | sed -E 's/\.jump,(.*)/\1/')
            jump=$(tail -n1 <<< "$jump")
            noloopback=$(grep -Eo '\.noloopback(\.|$)' <<< "$pattern")
            ip="127.0.0.1"
            [ -n "$jump" ] && OPTION+="-J $jump "
            if [ -n "$noloopback" ];then
                # IP harus ada di ~/.ssh/config
                ip=$(getIP "$host")
                if [ -z "$ip" ];then
                    echo IP Address for '"'$host'"' not found in ssh config. >&2
                    ip="$host"
                fi
            fi
            HOST="$host"
            # Jika ada variable `from`, maka perlu dapatkan ip.
            if [ -n "$from" ];then
                HOST="$from"
                # IP harus ada di ~/.ssh/config
                ip=$(getIP "$host")
                # Jika tidak ada, gunakan host, semoga resolver dari `from`
                # mengenali IP dari host.
                if [ -z "$ip" ];then
                    echo IP Address for '"'$host'"' not found in ssh config. >&2
                    ip="$host"
                fi
            fi
            case "$variant" in
                lpf)
                    OPTION+="-fN -L $local_port:$ip:$remote_port"
                    ;;
                rpf)
                    OPTION+="-fN -R $remote_port:$ip:$local_port"
            esac
            ;;
        dpf)
            local_port=$(grep -Eo '\.lport,[^.]+' <<< "$pattern" | sed -E 's/\.lport,(.*)/\1/')
            local_port=$(tail -n1 <<< "$local_port")
            HOST="$host"
            OPTION+="-fN -D $local_port"
            ;;
    esac
    case "$variant" in lpf|rpf|dpf)
        CMD=$(sed 's|OPTION|'"$OPTION"'|' <<< "$CMD")
        CMD=$(sed 's|HOST|'"$HOST"'|' <<< "$CMD")
        pid=$(getPid ssh "$CMD")
        magenta "$CMD"
        if [[ $pid == '' ]];then
            echo "$CMD" | sh
            pid=$(getPid ssh "$CMD")
        fi
        echo -n PID:' ' >&2
        yellow $pid
    esac
    # Trigger.
    case "$variant" in
        lpf)
            if [[ -n "$pid" ]];then
                ip="127.0.0.1"
                triggerusehost=$(grep -Eo '\.triggerusehost(\.|$)' <<< "$pattern")
                [ -z "$triggerusehost" ] || ip="$host"
                target_port=$local_port
            fi
            ;;
        go)
            target_port=$remote_port
    esac
    if [[ -z "$target_port" ]];then
        exit
    fi
    trigger=$(grep -Eo '\.trigger,[^.]+' <<< "$pattern" | sed -E 's/\.trigger,(.*)/\1/')
    trigger=$(tail -n1 <<< "$trigger")
    [ -n "$trigger" ] || trigger=auto
    if [[ $trigger == no ]];then
        exit
    elif [[ $trigger == auto ]];then
        case "$remote_port" in
            80) trigger=http;;
            22) trigger=scp;;
            5900) trigger=vnc;;
            3389) trigger=rdp;;
            1194) trigger=vpn;;
        esac
    fi
    case $trigger in
        http)
            magenta cmd.exe /C start http://$ip:$target_port
            cmd.exe /C start http://$ip:$target_port &>/dev/null
            ;;
        scp)
            # Tambahkan `%PROGRAMFILES(X86)%\WinSCP` di PATH-nya Windows.
            # Simpan session di WinSCP dengan format $host:$port
            cmd.exe /c where WinSCP.exe &>/dev/null && {
                magenta cmd.exe /C start WinSCP.exe $ip:$target_port
                cmd.exe /C start WinSCP.exe $ip:$target_port &>/dev/null &
            }
            ;;
        vnc)
            # Tambahkan `%PROGRAMFILES%\TightVNC` di PATH-nya Windows.
            # Simpan password dengan nama file `.vnc-default-passwd.txt`.
            # Lokasi di $HOME atau %USERPROFILE%
            cmd.exe /c where tvnviewer.exe &>/dev/null && {
                # Cari password di Home.
                args_other=
                if [ -f "$HOME/.vnc-default-passwd.txt" ];then
                    args_other=' -password='"$(<$HOME/.vnc-default-passwd.txt)"
                elif isWSL;then
                    path=$(cmd.exe /c echo %USERPROFILE% 2>/dev/null)
                    drive=$(echo "$path" | cut -c1-1 | tr [:upper:] [:lower:])
                    other=$(echo "$path" | cut -c3-)
                    other="${other//\\/\/}"
                    USERPROFILE="/mnt/${drive}${other}"
                    if [ -f "$USERPROFILE/.vnc-default-passwd.txt" ];then
                        args_other=' -password='"$(<$USERPROFILE/.vnc-default-passwd.txt)"
                    fi
                fi
                magenta cmd.exe /C start tvnviewer.exe -host=$ip -port=$target_port$args_other
                cmd.exe /C start tvnviewer.exe -host=$ip -port=$target_port$args_other &>/dev/null &
            }
            ;;
        rdp)
            magenta cmd.exe /C start mstsc /v:$ip:$target_port
            cmd.exe /C start mstsc /v:$ip:$target_port &>/dev/null &
            ;;
        vpn)
            # Tambahkan `%PROGRAMFILES%\OpenVPN\bin` di PATH-nya Windows.
            # Simpan config VPN dengan nama $ip-$target_port.ovpn
            cmd.exe /c where openvpn-gui.exe &>/dev/null && {
                magenta cmd.exe /C start openvpn-gui.exe --connect $ip-$target_port.ovpn
                cmd.exe /C start openvpn-gui.exe --connect $ip-$target_port.ovpn &>/dev/null &
            }
            ;;
    esac
}

__FILE__=$(realpath "$0")
__DIR__=$(dirname "$0")
pattern=$(basename "$0")
if [[ "$pattern" == 'ssh.sh' ]];then
    # Command.
    command="$1"; shift
    if [ -n "$command" ];then
        case "$command" in
            list|create|rename|delete|execute) ;;
            l) command=list;;
            c) command=create;;
            r) command=rename;;
            d) command=delete;;
            x) command=execute;;
            *) red "Command ${command} is unknown.""\e[39m" >&2; exit 1
        esac
        Ssh_$command "$@"
    fi
    [ -z "$command" ] && { printHelp; exit 1; }
else
    while [[ $# -gt 0 ]]; do
        pattern+=".${1}"
        shift
    done
    Ssh_execute "$pattern"
fi

# parse-options.sh \
# --without-end-options-double-dash \
# --compact \
# --clean \
# --no-hash-bang \
# --no-original-arguments \
# --no-error-invalid-options \
# --no-error-require-arguments << EOF | clip
# FLAG=(
# '--version|-v'
# '--help|-h'
# )
# VALUE=(
# )
# MULTIVALUE=(
# )
# FLAG_VALUE=(
# )
# CSV=(
# )
# EOF
# clear

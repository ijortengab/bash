#!/bin/bash

# Parse arguments. Generated by parse-options.sh
_new_arguments=()
while [[ $# -gt 0 ]]; do
    case "$1" in
        --help) help=1; shift ;;
        --version) version=1; shift ;;
        --dry-run|-n) dry_run=1; shift ;;
        --duration=*) duration="${1#*=}"; shift ;;
        --duration) if [[ ! $2 == "" && ! $2 =~ ^-[^-] ]]; then duration="$2"; shift; fi; shift ;;
        --if=*) if="${1#*=}"; shift ;;
        --if) if [[ ! $2 == "" && ! $2 =~ ^-[^-] ]]; then if="$2"; shift; fi; shift ;;
        --mode=*) mode="${1#*=}"; shift ;;
        --mode) if [[ ! $2 == "" && ! $2 =~ ^-[^-] ]]; then mode="$2"; shift; fi; shift ;;
        --then=*) then="${1#*=}"; shift ;;
        --then) if [[ ! $2 == "" && ! $2 =~ ^-[^-] ]]; then then="$2"; shift; fi; shift ;;
        --) shift
            while [[ $# -gt 0 ]]; do
                case "$1" in
                    *) _new_arguments+=("$1"); shift ;;
                esac
            done
            ;;
        --[^-]*) shift ;;
        *) _new_arguments+=("$1"); shift ;;
    esac
done
set -- "${_new_arguments[@]}"
unset _new_arguments

# Common Functions.
red() { echo -ne "\e[91m" >&2; echo -n "$@" >&2; echo -ne "\e[39m" >&2; }
green() { echo -ne "\e[92m" >&2; echo -n "$@" >&2; echo -ne "\e[39m" >&2; }
yellow() { echo -ne "\e[93m" >&2; echo -n "$@" >&2; echo -ne "\e[39m" >&2; }
blue() { echo -ne "\e[94m" >&2; echo -n "$@" >&2; echo -ne "\e[39m" >&2; }
magenta() { echo -ne "\e[95m" >&2; echo -n "$@" >&2; echo -ne "\e[39m" >&2; }
error() { echo -n "$INDENT" >&2; red '#' "$@" >&2; echo >&2; }
success() { echo -n "$INDENT" >&2; green '#' "$@" >&2; echo >&2; }
chapter() { echo -n "$INDENT" >&2; yellow '#' "$@" >&2; echo >&2; }
title() { echo -n "$INDENT" >&2; blue '#' "$@" >&2; echo >&2; }
code() { echo -n "$INDENT" >&2; magenta "$@" >&2; echo >&2; }
x() { echo >&2; exit 1; }
e() { echo -n "$INDENT" >&2; echo "#" "$@" >&2; }
_() { echo -n "$INDENT" >&2; echo -n "#" "$@" >&2; }
_,() { echo -n "$@" >&2; }
_.() { echo >&2; }
__() { echo -n "$INDENT" >&2; echo -n "#" '    ' >&2; [ -n "$1" ] && echo "$@" >&2 || echo -n  >&2; }
____() { echo >&2; [ -n "$delay" ] && sleep "$delay"; }

# Functions.
printVersion() {
    echo '0.2.0'
}
printHelp() {
    cat << 'EOF'

Adjust MTime is command in shell to adjust the modification time of file.

## Mode Filename

The date information must be provided in filename consisting of 14 digits
represents of YYYY-MM-DD-HH-MM-SS.

Getting Started.

  Just execute it.

  ```
  adjust-mtime --mode=filename IMG_20201202_143554.jpg
  ```

  ```
  adjust-mtime --mode=filename Screenshot_2020-12-04-07-27-06-328_com.whatsapp.png
  ```

For file video, add the duration of video only if there are not `ffmpeg`
in your system.

  ```
  adjust-mtime --mode=filename VID_20200714_141207.mp4
  ```

  ```
  adjust-mtime --mode=filename VID_20200715_141207.mp4 --duration 30
  ```

  ```
  adjust-mtime --mode=filename VID_20200716_141207.mp4 --duration 6:30
  ```

  ```
  adjust-mtime --mode=filename VID_20200717_141207.mp4 --duration 5:06:30
  ```

If there are not `ffmpeg` and you omitted the --duration option, the file
will not process.

Bulk Process
  Works well with asterix.

  ```
  adjust-mtime --mode=filename *.mp4
  ```

  or standard input.

  ```
  ls *.jpg | adjust-mtime --mode=filename
  ```

EOF
}

# Help and Version.
[ -n "$help" ] && { printHelp; exit 1; }
[ -n "$version" ] && { printVersion; exit 1; }

# Functions.
isVideo() {
    # For performance.
    case "$extension" in
        mp4) return 0 ;;
        mov) return 0 ;;
        jpg) return 1 ;;
    esac
    if [[ $(file "$full_path"  -i | sed -n 's!: video/[^:]*$!!p') ]];then
        return 0
    fi
    return 1
}
getDuration() {
    local _full_path="$full_path"
    if command -v ffmpeg &> /dev/null;then
        ffmpeg -i "$_full_path" 2>&1 | grep -o -P "(?<=Duration: ).*?(?=,)"
    elif command -v ffmpeg.exe &> /dev/null;then
        # ffmpeg.exe yang terinstal pada host Windows tidak mengenali path
        # Cygwin maupun WSL2, maka konversi "$full_path" ke path-nya Windows.
        # ffmpeg.exe bisa didapat dari Format Factory.
        if command -v cygpath.exe &> /dev/null;then
            # Jika command ini dieksekusi di Cygwin, maka:
            _full_path=$(cygpath.exe -w "$full_path")
        elif command -v wslpath &> /dev/null;then
            # Jika command ini dieksekusi di WSL2, maka:
            _full_path=$(wslpath -w "$full_path")
        fi
        ffmpeg.exe -i "$_full_path" 2>&1 | grep -o -P "(?<=Duration: ).*?(?=,)"
    fi
}

# Get files from standard input.
if [ ! -t 0 ]; then
    while read _each; do
        files_arguments+=("$_each")
    done </dev/stdin
fi

# Get files from argument.
while [[ $# -gt 0 ]]; do
    files_arguments+=("$1")
    shift
done

set -- "${files_arguments[@]}"

if [ "$1" == '' ];then
    cat <<- EOF >&2
Usage: adjust-mtime --mode=<filename|metadata|calibration> [options] <file|STDIN> [<file>]...
Try 'adjust-mtime --help' for more information.

Adjust Modified Time version `printVersion`.
EOF
    exit 1
fi

if [ -z "$mode" ];then
    error "Argument --mode required."; x
fi
case "$mode" in
    filename|metadata|calibration) ;;
    *) error "The value of --mode is not valid."; x
esac

if [[ $# -gt 1 && -n "$duration" ]];then
    error The --duration option can only be used with one operand.; x
fi

if [ -n "$duration" ];then
    if [ $# -gt 1 ];then
        error The --duration option can only be used with one operand.; x
    fi
    if grep -q -E '[^0-9:]' <<< "$duration";then
        error "The value of --duration is not valid."; x
    fi
fi

if [[ "$mode" == calibration ]];then
    if [ -z "$if" ];then
        error The --if option is required while use --mode=calibration.; x
    fi
    if [ -z "$then" ];then
        error The --then option is required while use --mode=calibration.; x
    fi
    if=$(echo "$if" | sed -E 's|[^0-9]||g')
    if [[ ! ${#if} == 14 ]];then
        error The --if option is require digit that represents of YYYYMMDDHHMMSS.; x
    fi
    then=$(echo "$then" | sed -E 's|[^0-9]||g')
    if [[ ! ${#then} == 14 ]];then
        error The --then option is require digit that represents of YYYYMMDDHHMMSS.; x
    fi
    _if=$(date -u -d "${if:0:8} ${if:8:2}:${if:10:2}:${if:12:2}" '+%s')
    _then=$(date -u -d "${then:0:8} ${then:8:2}:${then:10:2}:${then:12:2}" '+%s')
    modifier=$((_then-_if))
    operator=+
    if [ $_then -lt $_if ];then
        operator=-
    fi
    modifier="${operator}${modifier}"
fi

mktemp=
while [[ $# -gt 0 ]]; do
    full_path=$(realpath "$1")
    basename=$(basename -- "$full_path")
    if [ ! -f "$full_path" ];then
        yellow '[warning]'; _, ' 'File not found: '"'$1'"'.; _.
        shift
        continue
    fi
    extension="${basename##*.}"
    extension=$(echo "$extension" | tr '[:upper:]' '[:lower:]')
    filename="${basename%.*}"
    case $mode in
        calibration)
            s=$(date -r "$full_path" '+%Y%m%d%H%M%S')
            s=$(date -u -d "${s:0:8} ${s:8:2}:${s:10:2}:${s:12:2} UTC ${modifier} sec" '+%Y%m%d%H%M%S')
            if [ -n "$dry_run" ];then
                _, '[info]'; _, '    '; magenta touch -m '"'$1'"' -t ${s:0:12}.${s:12:14}; _.
            else
                if [ -z "$mktemp" ];then
                    mktemp=$(mktemp -p /dev/shm)
                fi
                touch -m "$1" -t "${s:0:12}.${s:12:14}" 2>"$mktemp" && {
                    # Success filename send to Stdout.
                    green '[success]'; _, ' '; magenta 'touch -m "'; echo -ne "\e[95m" >&2; echo -n "$1"; echo -ne "\e[39m" >&2; magenta '" -t '"${s:0:12}.${s:12:14}"; echo
                } || {
                    red '[error]';  _, '   '; magenta touch -m '"'$1'"' -t ${s:0:12}.${s:12:14}; _.
                    _, '          '; _, `<"$mktemp"`;_.
                }
            fi
            ;;
        filename)
            digit=$(echo "$filename" | sed -E 's|[^0-9]||g')
            s=${digit:0:14}
            if [[ ! ${#s} == 14 ]];then
                yellow '[warning]'; _, ' 'Digit that represents of YYYYMMDDHHMMSS not found in filename: '"'$1'"'.; _.
                shift
                continue
            fi
            modifier=
            if isVideo;then
                if [ -z "$duration" ];then
                    duration=`getDuration`
                fi
                if [ -z "$duration" ];then
                    yellow '[warning]'; _, ' 'Duration not found: '"'$1'"'. For precisision, add option '--duration=[[hh:]mm:]ss'.; _.
                    shift
                    continue
                fi
                add_s=$(echo $duration | grep -E -o "[0-9\.]+$")
                add_m=$(echo $duration | grep -E -o "[0-9]+:[0-9.]+$" | sed -E "s|:[0-9.]+$||")
                add_h=$(echo $duration | grep -E -o "[0-9]+:[0-9]+:[0-9.]+$" | sed -E "s|:[0-9]+:[0-9.]+$||")
                if [[ -n "$add_s" ]];then
                    add_s=`printf "%.0f" "$add_s"`
                    modifier="$add_s"
                fi
                if [[ -n "$add_m" ]];then
                    add_m=`printf "%.0f" "$add_m"`
                    add_m=$((add_m * 60))
                    modifier=$((modifier + add_m))
                fi
                if [[ -n "$add_h" ]];then
                    add_h=`printf "%.0f" "$add_h"`
                    add_h=$((add_h * 60 * 60))
                    modifier=$((modifier + add_h))
                fi
            fi
            if [ -n "$modifier" ];then
                s=$(date -u -d "${s:0:8} ${s:8:2}:${s:10:2}:${s:12:2} UTC ${modifier} sec" '+%Y%m%d%H%M%S')
            fi
            if [ -n "$dry_run" ];then
                _, '[info]'; _, '    '; magenta touch -m '"'$1'"' -t ${s:0:12}.${s:12:14}; _.
            else
                if [ -z "$mktemp" ];then
                    mktemp=$(mktemp -p /dev/shm)
                fi
                touch -m "$1" -t "${s:0:12}.${s:12:14}" 2>"$mktemp" && {
                    # Success filename send to Stdout.
                    green '[success]'; _, ' '; magenta 'touch -m "'; echo -ne "\e[95m" >&2; echo -n "$1"; echo -ne "\e[39m" >&2; magenta '" -t '"${s:0:12}.${s:12:14}"; echo
                } || {
                    red '[error]';  _, '   '; magenta touch -m '"'$1'"' -t ${s:0:12}.${s:12:14}; _.
                    _, '          '; _, `<"$mktemp"`;_.
                }
            fi
    esac
    if [[ $mode == metadata ]];then
        case "$extension" in
            mov)
                if ! command -v ffprobe >/dev/null;then
                    yellow '[warning]'; _, ' 'The '`'ffprobe'`' command is required. Metadata not found: '"'$1'"'.; _.
                    shift
                    continue
                else
                    format=$(ffprobe -v quiet -select_streams v:0  -show_entries stream_tags=creation_time -of default=noprint_wrappers=1:nokey=1 "$full_path")
                fi
                ;;
            heic)
                if ! command -v exiv2 >/dev/null;then
                    yellow '[warning]'; _, ' 'The '`'exiv2'`' command is required. Metadata not found: '"'$1'"'.; _.
                    shift
                    continue
                else
                    format=$(exiv2 --grep 'Image\.DateTime' "$full_path" | grep -E -o '(\S+\s+\S+)$' | sed -e 's,:,-,' -e 's,:,-,')
                fi
                ;;
            jpg|jpeg)
                if ! command -v exif >/dev/null;then
                    yellow '[warning]'; _, ' 'The '`'exif'`' command is required. Metadata not found: '"'$1'"'.; _.
                    shift
                    continue
                else
                    if grep -q -E 'Date and Time \(Original\)\s+.\s+.\s+\*' <<< `exif -l "$1"`;then
                        format=$(exif -t 'Date and Time (Original)' --machine-readable "$full_path" | sed -e 's,:,-,' -e 's,:,-,')
                    fi
                    if grep -q -E 'Offset Time For DateTimeOriginal\s+.\s+.\s+\*' <<< `exif -l "$1"`;then
                        _format=$(exif -t 'Offset Time For DateTimeOriginal' --machine-readable "$full_path")
                        format="${format} ${_format}"
                    fi
                fi
                ;;
            *)
                yellow '[warning]'; _, ' 'The extension is not support: '"'$1'"'.; _.
                shift
                continue
        esac
        if [ -n "$dry_run" ];then
            _, '[info]'; _, '    '; magenta touch -m '"'$1'"' -d '"'"$format"'"'; _.
        else
            if [ -z "$mktemp" ];then
                mktemp=$(mktemp -p /dev/shm)
            fi
            touch -m "$1" -d "$format" 2>"$mktemp" && {
                # Success filename send to Stdout.
                green '[success]'; _, ' '; magenta 'touch -m "'; echo -ne "\e[95m" >&2; echo -n "$1"; echo -ne "\e[39m" >&2; magenta '" -d "'"$format"'"'; echo
            } || {
                red '[error]';  _, '   '; magenta touch -m '"'$1'"' -d '"'"$format"'"'; _.
                _, '          '; _, `<"$mktemp"`;_.
            }
        fi
    fi
    # Reset.
    duration=
    shift
done
if [ -n "$mktemp" ];then
    rm "$mktemp"
fi

# parse-options.sh \
# --compact \
# --clean \
# --no-hash-bang \
# --no-original-arguments \
# --no-error-invalid-options \
# --no-error-require-arguments << EOF | clip
# FLAG=(
# '--dry-run|-n'
# --version
# --help
# )
# VALUE=(
# --mode
# --duration
# --if
# --then
# )
# EOF
# clear

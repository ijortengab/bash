#!/bin/bash
#
# Useful for creating tunnel with ssh.

# Parse arguments. Generated by parse-options.sh.
_new_arguments=()
while [[ $# -gt 0 ]]; do
    case "$1" in
        --help|-h) help=1; shift ;;
        --version|-v) version=1; shift ;;
        --countdown|-c) countdown=1; shift ;;
        --pid-file=*) pid_file="${1#*=}"; shift ;;
        --pid-file) if [[ ! $2 == "" && ! $2 =~ ^-[^-] ]]; then pid_file="$2"; shift; fi; shift ;;
        --timeout-trigger-command=*) timeout_trigger_command="${1#*=}"; shift ;;
        --timeout-trigger-command) if [[ ! $2 == "" && ! $2 =~ ^-[^-] ]]; then timeout_trigger_command="$2"; shift; fi; shift ;;
        --[^-]*) shift ;;
        *) _new_arguments+=("$1"); shift ;;
    esac
done
set -- "${_new_arguments[@]}"
_new_arguments=()
while [[ $# -gt 0 ]]; do
    case "$1" in
        -[^-]*) OPTIND=1
            while getopts ":hvc" opt; do
                case $opt in
                    h) help=1 ;;
                    v) version=1 ;;
                    c) countdown=1 ;;
                esac
            done
            shift "$((OPTIND-1))"
            ;;
        *) _new_arguments+=("$1"); shift ;;
    esac
done
set -- "${_new_arguments[@]}"
unset _new_arguments

# Operand.
command="$1"; shift

# Functions.
printVersion() {
    echo '0.1.1'
}
printHelp() {
    cat << 'EOF'
Usage: command-keep-alive.sh <command> [options]'

Options:
   --pid-file
        Set the pid file.
   --timeout-trigger-command
        Command to execute if timeout triggered.

Global Options:
   --version
        Print version of this script.
   --help
        Show this help.
EOF
}

# Help and Version.
[ -n "$version" ] && { printVersion; exit 1; }
[ -z "$command" ] && { printHelp; exit 1; }
[ -n "$help" ] && { printHelp; exit 1; }

# Functions.
getPid() {
    local command="$1" command_0 command_clean
    command_0=$(echo "$command" | cut -d' ' -f1)
    command_clean=${command%&} # remove suffix ampersand.
    command_clean=$(xargs <<< "$command_clean")
    # Global used: $USER, $IFS.
    if [[ $(uname) == "Linux" ]];then
        local pid
        [ -z "$USER" ] && USER=$(whoami)
        basename=$(basename "$__FILE__")
        pid=$(ps -u $USER -U $USER x | grep "$command_0" | grep -v grep | grep -v "$basename" | grep "$command_clean" | awk '{print $1}')
        echo $pid
    elif [[ $(uname | cut -c1-6) == "CYGWIN" ]];then
        local pid command ifs
        ifs=$IFS
        ps -s | grep "$command_0" | awk '{print $1}' | while IFS= read -r pid; do \
            command=$(cat /proc/${pid}/cmdline | tr '\0' ' ')
            command=$(echo "$command" | sed 's/\ $//')
            IFS=$ifs
            if [[ "$command" == "$command_clean" ]];then
                echo $pid
                break
            fi
        done
        IFS=$ifs
    fi
}
cleaning() {
    # Global used: $pid_file.
    local pid
    echo $(date +%Y%m%d-%H%M%S) '[cleaning]' Triggered. >&2
    pid=$(getPid "$command")
    if [[ $pid == '' ]];then
        echo $(date +%Y%m%d-%H%M%S) '[cleaning]' PID not found. >&2
    else
        echo $(date +%Y%m%d-%H%M%S) '[cleaning]' Kill PID $pid. >&2
        kill $pid
    fi
    rm "$pid_file"
    exit
}

# Require, validate, and populate value.
__FILE__=$(realpath "$0")
[ -z "$pid_file" ] &&  pid_file=$(mktemp -p /tmp command-keep-alive.XXXXXX.pid)

# Execute.
trap cleaning SIGTERM
trap cleaning SIGINT
echo $$ > "$pid_file"
echo $(date +%Y%m%d-%H%M%S) '[notice]' PID of command-keep-alive.sh:' '$$. >&2
echo $(date +%Y%m%d-%H%M%S) '[notice]' PID file:' '$pid_file. >&2
declare -i count
count=0
while true; do
    pid=$(getPid "$command")
    if [[ $pid == '' ]];then
        echo $(date +%Y%m%d-%H%M%S) '[execute]' "$command" >&2
        echo "$command" | sh
        echo $(date +%Y%m%d-%H%M%S) '[notice]' Exit code: $? >&2
        pid=$(getPid "$command")
    fi
    if [[ $pid == '' ]];then
        count+=1
        echo $(date +%Y%m%d-%H%M%S) '[notice]' PID of command is not found '('$count')'. >&2
        echo $(date +%Y%m%d-%H%M%S) '[notice]' Command to stop this process: '`'kill $$'`'. >&2
        if [ $count -eq 60 ];then
            echo $(date +%Y%m%d-%H%M%S) '[notice]' Timeout, wait a minute. >&2
            if [ -n "$timeout_trigger_command" ];then
                echo $(date +%Y%m%d-%H%M%S) '[execute]' "$timeout_trigger_command" >&2
                echo "$timeout_trigger_command" | sh
            fi
            sleep 59
            count=0
        fi
        sleep 1
    else
        echo $(date +%Y%m%d-%H%M%S) '[notice]' Command to stop this process: '`'kill $$'`'. >&2
        echo -n $(date +%Y%m%d-%H%M%S) >&2
        echo -n ' [notice] ' >&2
        echo -n 'PID of command: ' >&2
        echo $pid >&2
        declare -i countdown
        while kill -0 $pid 2>/dev/null
        do
            if [ -n "$countdown" ];then
                # Debug only.
                countdown=60
                while [ "$countdown" -ge 0 ]; do
                    printf "\r\033[K" >&2
                    printf %"$countdown"s | tr " " "." >&2
                    printf "\r"
                    countdown=$((countdown - 1))
                    sleep 1
                done
            else
                # Actual.
                sleep 60
            fi
        done
        echo $(date +%Y%m%d-%H%M%S) '[notice]' PID '`'$pid'`' was terminated. >&2
    fi
done

# parse-options.sh \
# --without-end-options-double-dash \
# --compact \
# --clean \
# --no-hash-bang \
# --no-original-arguments \
# --no-error-invalid-options \
# --no-error-require-arguments << EOF | clip
# FLAG=(
# '--version|-v'
# '--help|-h'
# '--countdown|-c'
# )
# VALUE=(
# --timeout-trigger-command
# --pid-file
# )
# MULTIVALUE=(
# )
# FLAG_VALUE=(
# )
# CSV=(
# )
# EOF
# clear

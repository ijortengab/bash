# Shell script development suggestions

## Key Learning

> We have to use `--with-end-options-first-operand` option, so the generated code behaves like the `ssh` command.

## Development

Assume that we are going to create a shell script like the `ssh` command.

Let's Define our options in the `ssh.options.sh` file.

The contents of `ssh.options.sh` file is:

```
#!/bin/bash

FLAG=(
    '-4'
)
VALUE=(
    '-l'
)
MULTIVALUE=(
    '-o'
)
INCREMENT=(
    '-v'
)

# Stop here.
source $(dirname $0)/../code-generator-parse-options.function.sh
CodeGeneratorParseOptions $@
```

Any arguments to `ssh.options.sh` file are passed to the `CodeGeneratorParseOptions()` function.

Let's evaluate the code generated by execute the `ssh.options.sh` file.

```
./ssh.options.sh --compact
```

Some part of the output.

```
# Processing standalone options.
while [[ $# -gt 0 ]]; do
    case "$1" in
        -4) _4=1; shift ;; # flag
        -l=*) l="${1#*=}"; shift ;; # value
        -l) if [[ ! $2 == "" && ! $2 =~ ^-[^-] ]]; then l="$2"; shift; else echo "Option $1 requires an argument." >&2; fi; shift ;; # value
        -o=*) o+=("${1#*=}"); shift ;; # multivalue
        -o) if [[ ! $2 == "" && ! $2 =~ ^-[^-] ]]; then o+=("$2"); shift; else echo "Option $1 requires an argument." >&2; fi; shift ;; # multivalue
        -v) v="$((v+1))"; shift ;; # increment
        --)
            while [[ $# -gt 0 ]]; do
                case "$1" in
                    *) _new_arguments+=("$1"); shift ;;
                esac
            done
            ;;
        --[^-]*) echo "Invalid option: $1" >&2; shift ;;
        *) _new_arguments+=("$1"); shift ;;
    esac
done
```

By default, the Code generated by `CodeGeneratorParseOptions` function interprets a double hyphen as the end of options.

From the generated code above, each option after the double hyphen (`--`) interpreted as an operand.

The `ssh` command has a unique argument format, which every argument after first operand interpreted as an operand.

It means the first operand is mark as the end of options.

From manual of `ssh` version `OpenSSH_7.6p1 Ubuntu-4ubuntu0.3, OpenSSL 1.0.2n  7 Dec 2017`:

```
SYNOPSIS
     ssh [all short options starting with single hyphen, are placed here] [user@]hostname [command]
```

We have to use `--with-end-options-first-operand` option, so the generated code behaves like the `ssh` command.

Execute the `ssh.options.sh` file again.

```
./ssh.options.sh --compact --with-end-options-first-operand
```

Some part of the output.

```
# Processing standalone options.
while [[ $# -gt 0 ]]; do
    case "$1" in
        -4) _4=1; shift ;; # flag
        -l=*) l="${1#*=}"; shift ;; # value
        -l) if [[ ! $2 == "" && ! $2 =~ ^-[^-] ]]; then l="$2"; shift; else echo "Option $1 requires an argument." >&2; fi; shift ;; # value
        -o=*) o+=("${1#*=}"); shift ;; # multivalue
        -o) if [[ ! $2 == "" && ! $2 =~ ^-[^-] ]]; then o+=("$2"); shift; else echo "Option $1 requires an argument." >&2; fi; shift ;; # multivalue
        -v) v="$((v+1))"; shift ;; # increment
        --)
            while [[ $# -gt 0 ]]; do
                case "$1" in
                    *) _new_arguments+=("$1"); shift ;;
                esac
            done
            ;;
        --[^-]*) echo "Invalid option: $1" >&2; shift ;;
        *)
            while [[ $# -gt 0 ]]; do
                case "$1" in
                    *) _new_arguments+=("$1"); shift ;;
                esac
            done
            ;;
    esac
done
```

The different is, before using the `--with-end-options-first-operand` option:

```
*) _new_arguments+=("$1"); shift ;;
```

After using the `--with-end-options-first-operand` option:

```
*)
    while [[ $# -gt 0 ]]; do
        case "$1" in
            *) _new_arguments+=("$1"); shift ;;
        esac
    done
    ;;
```

Lets using `--output-file` and `--debug-file` options to produce file that will be embedded.

```
./ssh.options.sh --with-end-options-first-operand --output-file ssh.parse_options.sh  --debug-file ssh.debug.sh
```

Now we have two new files named `ssh.parse_options.sh` and `ssh.debug.sh`.

Create a file for your development shell script. For example a file named `ssh.dev.sh`.

Add two lines inside `ssh.dev.sh` file for embedding.

```
source $(dirname $0)/ssh.parse_options.sh
source $(dirname $0)/ssh.debug.sh
```

Provide arguments for `ssh.dev.sh` with many variations.

```
./ssh.dev.sh -vvv
./ssh.dev.sh -l ijortengab -o "Port 443" -o "ProxyJump root@server.proxy.net" ijortengab.id
./ssh.dev.sh -l ijortengab ijortengab.id echo -n 1
```

You can now start developing your shell script in the `ssh.dev.sh` file.

## Build

Tips if you have done developing your shell script. Give your stable script a name, for example `ssh.sh`.

```
touch ssh.sh
chmod +x ssh.sh
```

Rerun the `ssh.options.sh` with `--no-hash-bang`, `--compact`, and `--clean` option.

```
./ssh.options.sh --with-end-options-first-operand --no-hash-bang --compact --clean --output-file ssh.parse_options.min.txt
```

This creates a minified version of `ssh.parse_options.sh` file and ready to embed.

Replace this line:

```
source $(dirname $0)/ssh.parse_options.sh
```

with the contents of `ssh.parse_options.min.txt` file, then release your stable script.

```
FILE2=$(<ssh.dev.sh) && \
FILE1=$(<ssh.parse_options.min.txt) && \
echo "${FILE2//source \$(dirname \$0)\/ssh.parse_options.sh/$FILE1}" > ssh.sh
```

Don't forget to remove the debug line:

```
source $(dirname $0)/ssh.debug.sh
```

with execute `sed`.

```
sed -i '/source \$(dirname \$0)\/ssh.debug.sh/d' ./ssh.sh
```

Now, your stable script is ready.

```
./ssh.sh
```
